# es6learning

# 第一讲 let 和 const 命令

## 1、let命令
### （1）基本用法
### （2）不存在变量提升
### （3）暂时性死区
var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined   <br />
如果区块中存在let和const命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。     <br />
暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。    <br />

    var tmp = 123;

    if (true) {
      tmp = 'abc'; // ReferenceError
      let tmp;
    }

### （4）不允许重复申明


## 2、块级作用域
### （1）ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。    <br />
>第一种场景，内层变量可能会覆盖外层变量。                                         <br />
>第二种场景，用来计数的循环变量泄露为全局变量。                                        <br />

### （2）ES6 的块级作用域   <br />
>let实际上为 JavaScript 新增了块级作用域。                                  <br />
>ES6 允许块级作用域的任意嵌套，外层作用域无法读取内层作用域的变量。              <br />
>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。     <br />

### （3）块级作用域与函数声明
        // 情况一
        if (true) {
          function f() {}
        }

        // 情况二
        try {
          function f() {}
        } catch(e) {
          // ...
        }

>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。      <br />
>在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。   <br />
>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。   <br />
>还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。   <br />
        // 不报错
        'use strict';
        if (true) {
          function f() {}
        }

        // 报错
        'use strict';
        if (true)
          function f() {}

## 3、const命令
